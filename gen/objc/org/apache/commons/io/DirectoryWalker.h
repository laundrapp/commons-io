//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/marcussmith/temp/commons-io/src/main/java/org/apache/commons/io/DirectoryWalker.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_OrgApacheCommonsIoDirectoryWalker")
#ifdef RESTRICT_OrgApacheCommonsIoDirectoryWalker
#define INCLUDE_ALL_OrgApacheCommonsIoDirectoryWalker 0
#else
#define INCLUDE_ALL_OrgApacheCommonsIoDirectoryWalker 1
#endif
#undef RESTRICT_OrgApacheCommonsIoDirectoryWalker

#if !defined (OrgApacheCommonsIoDirectoryWalker_) && (INCLUDE_ALL_OrgApacheCommonsIoDirectoryWalker || defined(INCLUDE_OrgApacheCommonsIoDirectoryWalker))
#define OrgApacheCommonsIoDirectoryWalker_

@class IOSObjectArray;
@class JavaIoFile;
@class OrgApacheCommonsIoDirectoryWalker_CancelException;
@protocol JavaIoFileFilter;
@protocol JavaUtilCollection;
@protocol OrgApacheCommonsIoFilefilterIOFileFilter;

/*!
 @brief Abstract class that walks through a directory hierarchy and provides
  subclasses with convenient hooks to add specific behaviour.
 <p>
  This class operates with a <code>FileFilter</code> and maximum depth to
  limit the files and direcories visited.
  Commons IO supplies many common filter implementations in the  
 <a href="filefilter/package-summary.html"> filefilter</a> package. 
 <p>
  The following sections describe:
    <ul>
       <li><a href="#example">1. Example Implementation</a> - example
           <code>FileCleaner</code> implementation.</li>
       <li><a href="#filter">2. Filter Example</a> - using 
           <code>FileFilter</code>(s) with <code>DirectoryWalker</code>.</li>
       <li><a href="#cancel">3. Cancellation</a> - how to implement cancellation
           behaviour.</li>
    </ul>
  
 <a name="example"></a>
  <h3>1. Example Implementation</h3>
  There are many possible extensions, for example, to delete all
  files and '.svn' directories, and return a list of deleted files: 
 @code

   public class FileCleaner extends DirectoryWalker {
     public FileCleaner() {
       super();
     }
     public List clean(File startDirectory) {
       List results = new ArrayList();
       walk(startDirectory, results);
       return results;
     }
     protected boolean handleDirectory(File directory, int depth, Collection results) {
       // delete svn directories and then skip
       if (".svn".equals(directory.getName())) {
         directory.delete();
         return false;
       } else {
         return true;
       }     }
     protected void handleFile(File file, int depth, Collection results) {
       // delete file and add to list of deleted
       file.delete();
       results.add(file);
     }   }  
  
@endcode
  
 <a name="filter"></a>
  <h3>2. Filter Example</h3>
  Choosing which directories and files to process can be a key aspect
  of using this class. This information can be setup in three ways,
  via three different constructors. 
 <p>
  The first option is to visit all directories and files.
  This is achieved via the no-args constructor. 
 <p>
  The second constructor option is to supply a single <code>FileFilter</code>
  that describes the files and directories to visit. Care must be taken
  with this option as the same filter is used for both directories
  and files. 
 <p>
  For example, if you wanted all directories which are not hidden
  and files which end in ".txt": 
 @code

   public class FooDirectoryWalker extends DirectoryWalker {
     public FooDirectoryWalker(FileFilter filter) {
       super(filter, -1);
     }   }   
   // Build up the filters and create the walker
     // Create a filter for Non-hidden directories
     IOFileFilter fooDirFilter = 
         FileFilterUtils.andFileFilter(FileFilterUtils.directoryFileFilter,
                                       HiddenFileFilter.VISIBLE);
     // Create a filter for Files ending in ".txt"
     IOFileFilter fooFileFilter = 
         FileFilterUtils.andFileFilter(FileFilterUtils.fileFileFilter,
                                       FileFilterUtils.suffixFileFilter(".txt"));
     // Combine the directory and file filters using an OR condition
     java.io.FileFilter fooFilter = 
         FileFilterUtils.orFileFilter(fooDirFilter, fooFileFilter);
     // Use the filter to construct a DirectoryWalker implementation
     FooDirectoryWalker walker = new FooDirectoryWalker(fooFilter); 
  
@endcode
  <p>
  The third constructor option is to specify separate filters, one for
  directories and one for files. These are combined internally to form
  the correct <code>FileFilter</code>, something which is very easy to
  get wrong when attempted manually, particularly when trying to
  express constructs like 'any file in directories named docs'. 
 <p>
  For example, if you wanted all directories which are not hidden
  and files which end in ".txt": 
 @code

   public class FooDirectoryWalker extends DirectoryWalker {
     public FooDirectoryWalker(IOFileFilter dirFilter, IOFileFilter fileFilter) {
       super(dirFilter, fileFilter, -1);
     }   }   
   // Use the filters to construct the walker
   FooDirectoryWalker walker = new FooDirectoryWalker(
     HiddenFileFilter.VISIBLE,
     FileFilterUtils.suffixFileFilter(".txt"),
   ); 
  
@endcode
  This is much simpler than the previous example, and is why it is the preferred
  option for filtering. 
 <a name="cancel"></a>
  <h3>3. Cancellation</h3>
  The DirectoryWalker contains some of the logic required for cancel processing.
  Subclasses must complete the implementation. 
 <p>
  What <code>DirectoryWalker</code> does provide for cancellation is: 
 <ul>
     <li><code>CancelException</code> which can be thrown in any of the
         <i>lifecycle</i> methods to stop processing.</li>
     <li>The <code>walk()</code> method traps thrown <code>CancelException</code>
         and calls the <code>handleCancelled()</code> method, providing
         a place for custom cancel processing.</li>
  </ul>
  <p>
  Implementations need to provide: 
 <ul>
     <li>The decision logic on whether to cancel processing or not.</li>
     <li>Constructing and throwing a <code>CancelException</code>.</li>
     <li>Custom cancel processing in the <code>handleCancelled()</code> method. 
 </ul>
  <p>
  Two possible scenarios are envisaged for cancellation: 
 <ul>
     <li><a href="#external">3.1 External / Mult-threaded</a> - cancellation being
         decided/initiated by an external process.</li>
     <li><a href="#internal">3.2 Internal</a> - cancellation being decided/initiated 
         from within a DirectoryWalker implementation.</li>
  </ul>
  <p>
  The following sections provide example implementations for these two different
  scenarios. 
 <a name="external"></a>
  <h4>3.1 External / Multi-threaded</h4>
  This example provides a public <code>cancel()</code> method that can be
  called by another thread to stop the processing. A typical example use-case
  would be a cancel button on a GUI. Calling this method sets a 
 <a href="http://java.sun.com/docs/books/jls/second_edition/html/classes.doc.html#36930">
  volatile</a> flag to ensure it will work properly in a multi-threaded environment.
  The flag is returned by the <code>handleIsCancelled()</code> method, which
  will cause the walk to stop immediately. The <code>handleCancelled()</code>
  method will be the next, and last, callback method received once cancellation
  has occurred. 
 @code

   public class FooDirectoryWalker extends DirectoryWalker {
     private volatile boolean cancelled = false;
     public void cancel() {
         cancelled = true;
     }
     private void handleIsCancelled(File file, int depth, Collection results) {
         return cancelled;
     }
     protected void handleCancelled(File startDirectory, Collection results, CancelException cancel) {
         // implement processing required when a cancellation occurs
     }   }  
  
@endcode
  
 <a name="internal"></a>
  <h4>3.2 Internal</h4>
  This shows an example of how internal cancellation processing could be implemented. 
 <b>Note</b> the decision logic and throwing a <code>CancelException</code> could be implemented
  in any of the <i>lifecycle</i> methods.  
 @code

   public class BarDirectoryWalker extends DirectoryWalker {
     protected boolean handleDirectory(File directory, int depth, Collection results) throws IOException {
         // cancel if hidden directory
         if (directory.isHidden()) {
             throw new CancelException(file, depth);
         }
         return true;
     }
     protected void handleFile(File file, int depth, Collection results) throws IOException {
         // cancel if read-only file
         if (!file.canWrite()) {
             throw new CancelException(file, depth);
         }
         results.add(file);
     }
     protected void handleCancelled(File startDirectory, Collection results, CancelException cancel) {
         // implement processing required when a cancellation occurs
     }   }  
  
@endcode
 @since 1.3
 @version $Id$
 */
@interface OrgApacheCommonsIoDirectoryWalker : NSObject

#pragma mark Protected

/*!
 @brief Construct an instance with no filtering and unlimited <i>depth</i>.
 */
- (instancetype)init;

/*!
 @brief Construct an instance with a filter and limit the <i>depth</i> navigated to.
 <p>
  The filter controls which files and directories will be navigated to as
  part of the walk. The <code>FileFilterUtils</code> class is useful for combining
  various filters together. A <code>null</code> filter means that no
  filtering should occur and all files and directories will be visited.
 @param filter the filter to apply, null means visit all files
 @param depthLimit controls how  <i> deep </i>  the hierarchy is
    navigated to (less than 0 means unlimited)
 */
- (instancetype)initWithJavaIoFileFilter:(id<JavaIoFileFilter>)filter
                                 withInt:(jint)depthLimit;

/*!
 @brief Construct an instance with a directory and a file filter and an optional
  limit on the <i>depth</i> navigated to.
 <p>
  The filters control which files and directories will be navigated to as part
  of the walk. This constructor uses <code>FileFilterUtils.makeDirectoryOnly(IOFileFilter)</code>
  and <code>FileFilterUtils.makeFileOnly(IOFileFilter)</code> internally to combine the filters.
  A <code>null</code> filter means that no filtering should occur.
 @param directoryFilter the filter to apply to directories, null means visit all directories
 @param fileFilter the filter to apply to files, null means visit all files
 @param depthLimit controls how  <i> deep </i>  the hierarchy is
    navigated to (less than 0 means unlimited)
 */
- (instancetype)initWithOrgApacheCommonsIoFilefilterIOFileFilter:(id<OrgApacheCommonsIoFilefilterIOFileFilter>)directoryFilter
                    withOrgApacheCommonsIoFilefilterIOFileFilter:(id<OrgApacheCommonsIoFilefilterIOFileFilter>)fileFilter
                                                         withInt:(jint)depthLimit;

/*!
 @brief Checks whether the walk has been cancelled by calling <code>handleIsCancelled</code>,
  throwing a <code>CancelException</code> if it has.
 <p>
  Writers of subclasses should not normally call this method as it is called
  automatically by the walk of the tree. However, sometimes a single method,
  typically <code>handleFile</code>, may take a long time to run. In that case,
  you may wish to check for cancellation by calling this method.
 @param file the current file being processed
 @param depth the current file level (starting directory = 0)
 @param results the collection of result objects, may be updated
 @throw IOExceptionif an I/O Error occurs
 */
- (void)checkIfCancelledWithJavaIoFile:(JavaIoFile *)file
                               withInt:(jint)depth
                withJavaUtilCollection:(id<JavaUtilCollection>)results;

/*!
 @brief Overridable callback method invoked with the contents of each directory.
 <p>
  This implementation returns the files unchanged
 @param directory the current directory being processed
 @param depth the current directory level (starting directory = 0)
 @param files the files (possibly filtered) in the directory
 @return the filtered list of files
 @throw IOExceptionif an I/O Error occurs
 @since 2.0
 */
- (IOSObjectArray *)filterDirectoryContentsWithJavaIoFile:(JavaIoFile *)directory
                                                  withInt:(jint)depth
                                      withJavaIoFileArray:(IOSObjectArray *)files;

/*!
 @brief Overridable callback method invoked when the operation is cancelled.
 The file being processed when the cancellation occurred can be
  obtained from the exception. 
 <p>
  This implementation just re-throws the <code>CancelException</code>.
 @param startDirectory the directory that the walk started from
 @param results the collection of result objects, may be updated
 @param cancel the exception throw to cancel further processing  containing details at the point of cancellation.
 @throw IOExceptionif an I/O Error occurs
 */
- (void)handleCancelledWithJavaIoFile:(JavaIoFile *)startDirectory
               withJavaUtilCollection:(id<JavaUtilCollection>)results
withOrgApacheCommonsIoDirectoryWalker_CancelException:(OrgApacheCommonsIoDirectoryWalker_CancelException *)cancel;

/*!
 @brief Overridable callback method invoked to determine if a directory should be processed.
 <p>
  This method returns a boolean to indicate if the directory should be examined or not.
  If you return false, the entire directory and any subdirectories will be skipped.
  Note that this functionality is in addition to the filtering by file filter. 
 <p>
  This implementation does nothing and returns true.
 @param directory the current directory being processed
 @param depth the current directory level (starting directory = 0)
 @param results the collection of result objects, may be updated
 @return true to process this directory, false to skip this directory
 @throw IOExceptionif an I/O Error occurs
 */
- (jboolean)handleDirectoryWithJavaIoFile:(JavaIoFile *)directory
                                  withInt:(jint)depth
                   withJavaUtilCollection:(id<JavaUtilCollection>)results;

/*!
 @brief Overridable callback method invoked at the end of processing each directory.
 <p>
  This implementation does nothing.
 @param directory the directory being processed
 @param depth the current directory level (starting directory = 0)
 @param results the collection of result objects, may be updated
 @throw IOExceptionif an I/O Error occurs
 */
- (void)handleDirectoryEndWithJavaIoFile:(JavaIoFile *)directory
                                 withInt:(jint)depth
                  withJavaUtilCollection:(id<JavaUtilCollection>)results;

/*!
 @brief Overridable callback method invoked at the start of processing each directory.
 <p>
  This implementation does nothing.
 @param directory the current directory being processed
 @param depth the current directory level (starting directory = 0)
 @param results the collection of result objects, may be updated
 @throw IOExceptionif an I/O Error occurs
 */
- (void)handleDirectoryStartWithJavaIoFile:(JavaIoFile *)directory
                                   withInt:(jint)depth
                    withJavaUtilCollection:(id<JavaUtilCollection>)results;

/*!
 @brief Overridable callback method invoked at the end of processing.
 <p>
  This implementation does nothing.
 @param results the collection of result objects, may be updated
 @throw IOExceptionif an I/O Error occurs
 */
- (void)handleEndWithJavaUtilCollection:(id<JavaUtilCollection>)results;

/*!
 @brief Overridable callback method invoked for each (non-directory) file.
 <p>
  This implementation does nothing.
 @param file the current file being processed
 @param depth the current directory level (starting directory = 0)
 @param results the collection of result objects, may be updated
 @throw IOExceptionif an I/O Error occurs
 */
- (void)handleFileWithJavaIoFile:(JavaIoFile *)file
                         withInt:(jint)depth
          withJavaUtilCollection:(id<JavaUtilCollection>)results;

/*!
 @brief Overridable callback method invoked to determine if the entire walk
  operation should be immediately cancelled.
 <p>
  This method should be implemented by those subclasses that want to
  provide a public <code>cancel()</code> method available from another
  thread. The design pattern for the subclass should be as follows: 
 @code

   public class FooDirectoryWalker extends DirectoryWalker {
     private volatile boolean cancelled = false;
     public void cancel() {
         cancelled = true;
     }
     private void handleIsCancelled(File file, int depth, Collection results) {
         return cancelled;
     }
     protected void handleCancelled(File startDirectory,
               Collection results, CancelException cancel) {
         // implement processing required when a cancellation occurs
     }   }  
  
@endcode
  <p>
  If this method returns true, then the directory walk is immediately
  cancelled. The next callback method will be <code>handleCancelled</code>.
  <p>
  This implementation returns false.
 @param file the file or directory being processed
 @param depth the current directory level (starting directory = 0)
 @param results the collection of result objects, may be updated
 @return true if the walk has been cancelled
 @throw IOExceptionif an I/O Error occurs
 */
- (jboolean)handleIsCancelledWithJavaIoFile:(JavaIoFile *)file
                                    withInt:(jint)depth
                     withJavaUtilCollection:(id<JavaUtilCollection>)results;

/*!
 @brief Overridable callback method invoked for each restricted directory.
 <p>
  This implementation does nothing.
 @param directory the restricted directory
 @param depth the current directory level (starting directory = 0)
 @param results the collection of result objects, may be updated
 @throw IOExceptionif an I/O Error occurs
 */
- (void)handleRestrictedWithJavaIoFile:(JavaIoFile *)directory
                               withInt:(jint)depth
                withJavaUtilCollection:(id<JavaUtilCollection>)results;

/*!
 @brief Overridable callback method invoked at the start of processing.
 <p>
  This implementation does nothing.
 @param startDirectory the directory to start from
 @param results the collection of result objects, may be updated
 @throw IOExceptionif an I/O Error occurs
 */
- (void)handleStartWithJavaIoFile:(JavaIoFile *)startDirectory
           withJavaUtilCollection:(id<JavaUtilCollection>)results;

/*!
 @brief Internal method that walks the directory hierarchy in a depth-first manner.
 <p>
  Users of this class do not need to call this method. This method will
  be called automatically by another (public) method on the specific subclass. 
 <p>
  Writers of subclasses should call this method to start the directory walk.
  Once called, this method will emit events as it walks the hierarchy.
  The event methods have the prefix <code>handle</code>.
 @param startDirectory the directory to start from, not null
 @param results the collection of result objects, may be updated
 @throw NullPointerExceptionif the start directory is null
 @throw IOExceptionif an I/O Error occurs
 */
- (void)walkWithJavaIoFile:(JavaIoFile *)startDirectory
    withJavaUtilCollection:(id<JavaUtilCollection>)results;

@end

J2OBJC_EMPTY_STATIC_INIT(OrgApacheCommonsIoDirectoryWalker)

FOUNDATION_EXPORT void OrgApacheCommonsIoDirectoryWalker_init(OrgApacheCommonsIoDirectoryWalker *self);

FOUNDATION_EXPORT void OrgApacheCommonsIoDirectoryWalker_initWithJavaIoFileFilter_withInt_(OrgApacheCommonsIoDirectoryWalker *self, id<JavaIoFileFilter> filter, jint depthLimit);

FOUNDATION_EXPORT void OrgApacheCommonsIoDirectoryWalker_initWithOrgApacheCommonsIoFilefilterIOFileFilter_withOrgApacheCommonsIoFilefilterIOFileFilter_withInt_(OrgApacheCommonsIoDirectoryWalker *self, id<OrgApacheCommonsIoFilefilterIOFileFilter> directoryFilter, id<OrgApacheCommonsIoFilefilterIOFileFilter> fileFilter, jint depthLimit);

J2OBJC_TYPE_LITERAL_HEADER(OrgApacheCommonsIoDirectoryWalker)

#endif

#if !defined (OrgApacheCommonsIoDirectoryWalker_CancelException_) && (INCLUDE_ALL_OrgApacheCommonsIoDirectoryWalker || defined(INCLUDE_OrgApacheCommonsIoDirectoryWalker_CancelException))
#define OrgApacheCommonsIoDirectoryWalker_CancelException_

#define RESTRICT_JavaIoIOException 1
#define INCLUDE_JavaIoIOException 1
#include "java/io/IOException.h"

@class JavaIoFile;
@class JavaLangThrowable;

/*!
 @brief CancelException is thrown in DirectoryWalker to cancel the current
  processing.
 */
@interface OrgApacheCommonsIoDirectoryWalker_CancelException : JavaIoIOException

#pragma mark Public

/*!
 @brief Constructs a <code>CancelException</code> with
  the file and depth when cancellation occurred.
 @param file the file when the operation was cancelled, may be null
 @param depth the depth when the operation was cancelled, may be null
 */
- (instancetype)initWithJavaIoFile:(JavaIoFile *)file
                           withInt:(jint)depth;

/*!
 @brief Constructs a <code>CancelException</code> with
  an appropriate message and the file and depth when
  cancellation occurred.
 @param message the detail message
 @param file the file when the operation was cancelled
 @param depth the depth when the operation was cancelled
 */
- (instancetype)initWithNSString:(NSString *)message
                  withJavaIoFile:(JavaIoFile *)file
                         withInt:(jint)depth;

/*!
 @brief Return the depth when the operation was cancelled.
 @return the depth when the operation was cancelled
 */
- (jint)getDepth;

/*!
 @brief Return the file when the operation was cancelled.
 @return the file when the operation was cancelled
 */
- (JavaIoFile *)getFile;

// Disallowed inherited constructors, do not use.

- (instancetype)init NS_UNAVAILABLE;

- (instancetype)initWithJavaLangThrowable:(JavaLangThrowable *)arg0 NS_UNAVAILABLE;

- (instancetype)initWithNSString:(NSString *)arg0 NS_UNAVAILABLE;

- (instancetype)initWithNSString:(NSString *)arg0
           withJavaLangThrowable:(JavaLangThrowable *)arg1 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(OrgApacheCommonsIoDirectoryWalker_CancelException)

FOUNDATION_EXPORT void OrgApacheCommonsIoDirectoryWalker_CancelException_initWithJavaIoFile_withInt_(OrgApacheCommonsIoDirectoryWalker_CancelException *self, JavaIoFile *file, jint depth);

FOUNDATION_EXPORT OrgApacheCommonsIoDirectoryWalker_CancelException *new_OrgApacheCommonsIoDirectoryWalker_CancelException_initWithJavaIoFile_withInt_(JavaIoFile *file, jint depth) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgApacheCommonsIoDirectoryWalker_CancelException *create_OrgApacheCommonsIoDirectoryWalker_CancelException_initWithJavaIoFile_withInt_(JavaIoFile *file, jint depth);

FOUNDATION_EXPORT void OrgApacheCommonsIoDirectoryWalker_CancelException_initWithNSString_withJavaIoFile_withInt_(OrgApacheCommonsIoDirectoryWalker_CancelException *self, NSString *message, JavaIoFile *file, jint depth);

FOUNDATION_EXPORT OrgApacheCommonsIoDirectoryWalker_CancelException *new_OrgApacheCommonsIoDirectoryWalker_CancelException_initWithNSString_withJavaIoFile_withInt_(NSString *message, JavaIoFile *file, jint depth) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgApacheCommonsIoDirectoryWalker_CancelException *create_OrgApacheCommonsIoDirectoryWalker_CancelException_initWithNSString_withJavaIoFile_withInt_(NSString *message, JavaIoFile *file, jint depth);

J2OBJC_TYPE_LITERAL_HEADER(OrgApacheCommonsIoDirectoryWalker_CancelException)

#endif

#pragma pop_macro("INCLUDE_ALL_OrgApacheCommonsIoDirectoryWalker")
