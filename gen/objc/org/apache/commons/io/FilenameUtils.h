//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/marcussmith/temp/commons-io/src/main/java/org/apache/commons/io/FilenameUtils.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_OrgApacheCommonsIoFilenameUtils")
#ifdef RESTRICT_OrgApacheCommonsIoFilenameUtils
#define INCLUDE_ALL_OrgApacheCommonsIoFilenameUtils 0
#else
#define INCLUDE_ALL_OrgApacheCommonsIoFilenameUtils 1
#endif
#undef RESTRICT_OrgApacheCommonsIoFilenameUtils

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (OrgApacheCommonsIoFilenameUtils_) && (INCLUDE_ALL_OrgApacheCommonsIoFilenameUtils || defined(INCLUDE_OrgApacheCommonsIoFilenameUtils))
#define OrgApacheCommonsIoFilenameUtils_

@class IOSObjectArray;
@class OrgApacheCommonsIoIOCase;
@protocol JavaUtilCollection;

/*!
 @brief General filename and filepath manipulation utilities.
 <p>
  When dealing with filenames you can hit problems when moving from a Windows
  based development machine to a Unix based production machine.
  This class aims to help avoid those problems. 
 <p>
  <b>NOTE</b>: You may be able to avoid using this class entirely simply by
  using JDK <code>File</code> objects and the two argument constructor 
 <code>File(File,String)</code>.
  <p>
  Most methods on this class are designed to work the same on both Unix and Windows.
  Those that don't include 'System', 'Unix' or 'Windows' in their name. 
 <p>
  Most methods recognise both separators (forward and back), and both
  sets of prefixes. See the javadoc of each method for details. 
 <p>
  This class defines six components within a filename
  (example C:\dev\project\file.txt): 
 <ul>
  <li>the prefix - C:\</li>
  <li>the path - dev\project\</li>
  <li>the full path - C:\dev\project\</li>
  <li>the name - file.txt</li>
  <li>the base name - file</li>
  <li>the extension - txt</li>
  </ul>
  Note that this class works best if directory filenames end with a separator.
  If you omit the last separator, it is impossible to determine if the filename
  corresponds to a file or a directory. As a result, we have chosen to say
  it corresponds to a file. 
 <p>
  This class only supports Unix and Windows style names.
  Prefixes are matched as follows: 
 @code

  Windows:
  a\b\c.txt           --> ""          --> relative
  \a\b\c.txt          --> "\"         --> current drive absolute
  C:a\b\c.txt         --> "C:"        --> drive relative
  C:\a\b\c.txt        --> "C:\"       --> absolute
  \\server\a\b\c.txt  --> "\\server\" --> UNC
  Unix:
  a/b/c.txt           --> ""          --> relative
  /a/b/c.txt          --> "/"         --> absolute
  ~/a/b/c.txt         --> "~/"        --> current user
  ~                   --> "~/"        --> current user (slash added)
  ~user/a/b/c.txt     --> "~user/"    --> named user
  ~user               --> "~user/"    --> named user (slash added) 
  
@endcode
  Both prefix styles are matched always, irrespective of the machine that you are
  currently running on. 
 <p>
  Origin of code: Excalibur, Alexandria, Tomcat, Commons-Utils.
 @version $Id$
 @since 1.1
 */
@interface OrgApacheCommonsIoFilenameUtils : NSObject

#pragma mark Public

/*!
 @brief Instances should NOT be constructed in standard programming.
 */
- (instancetype __nonnull)init;

/*!
 @brief Concatenates a filename to a base path using normal command line style rules.
 <p>
  The effect is equivalent to resultant directory after changing
  directory to the first argument, followed by changing directory to
  the second argument. 
 <p>
  The first argument is the base path, the second is the path to concatenate.
  The returned path is always normalized via <code>normalize(String)</code>,
  thus <code>..</code> is handled. 
 <p>
  If <code>pathToAdd</code> is absolute (has an absolute prefix), then
  it will be normalized and returned.
  Otherwise, the paths will be joined, normalized and returned. 
 <p>
  The output will be the same on both Unix and Windows except
  for the separator character. 
 @code

  /foo/ + bar          -->   /foo/bar
  /foo + bar           -->   /foo/bar
  /foo + /bar          -->   /bar
  /foo + C:/bar        -->   C:/bar
  /foo + C:bar         -->   C:bar (*)
  /foo/a/ + ../bar     -->   foo/bar
  /foo/ + ../../bar    -->   null
  /foo/ + /bar         -->   /bar
  /foo/.. + /bar       -->   /bar
  /foo + bar/c.txt     -->   /foo/bar/c.txt
  /foo/c.txt + bar     -->   /foo/c.txt/bar (!) 
  
@endcode
  (*) Note that the Windows relative drive prefix is unreliable when
  used with this method.
  (!) Note that the first parameter must be a path. If it ends with a name, then
  the name will be built into the concatenated path. If this might be a problem,
  use <code>getFullPath(String)</code> on the base path argument.
 @param basePath the base path to attach to, always treated as a path
 @param fullFilenameToAdd the filename (or path) to attach to the base
 @return the concatenated path, or null if invalid
 */
+ (NSString *)concatWithNSString:(NSString *)basePath
                    withNSString:(NSString *)fullFilenameToAdd;

/*!
 @brief Determines whether the <code>parent</code> directory contains the <code>child</code> element (a file or directory).
 <p>
  The files names are expected to be normalized. 
 </p>
  
  Edge cases: 
 <ul>
  <li>A <code>directory</code> must not be null: if null, throw IllegalArgumentException</li>
  <li>A directory does not contain itself: return false</li>
  <li>A null child file is not contained in any parent: return false</li>
  </ul>
 @param canonicalParent the file to consider as the parent.
 @param canonicalChild the file to consider as the child.
 @return true is the candidate leaf is under by the specified composite. False otherwise.
 @throw IOException
 if an IO error occurs while checking the files.
 @since 2.2
 - seealso: FileUtils#directoryContains(File, File)
 */
+ (jboolean)directoryContainsWithNSString:(NSString *)canonicalParent
                             withNSString:(NSString *)canonicalChild;

/*!
 @brief Checks whether two filenames are equal exactly.
 <p>
  No processing is performed on the filenames other than comparison,
  thus this is merely a null-safe case-sensitive equals.
 @param filename1 the first filename to query, may be null
 @param filename2 the second filename to query, may be null
 @return true if the filenames are equal, null equals null
 - seealso: IOCase#SENSITIVE
 */
+ (jboolean)equalsWithNSString:(NSString *)filename1
                  withNSString:(NSString *)filename2;

/*!
 @brief Checks whether two filenames are equal, optionally normalizing and providing
  control over the case-sensitivity.
 @param filename1 the first filename to query, may be null
 @param filename2 the second filename to query, may be null
 @param normalized whether to normalize the filenames
 @param caseSensitivity what case sensitivity rule to use, null means case-sensitive
 @return true if the filenames are equal, null equals null
 @since 1.3
 */
+ (jboolean)equalsWithNSString:(NSString *)filename1
                  withNSString:(NSString *)filename2
                   withBoolean:(jboolean)normalized
  withOrgApacheCommonsIoIOCase:(OrgApacheCommonsIoIOCase *)caseSensitivity;

/*!
 @brief Checks whether two filenames are equal after both have been normalized.
 <p>
  Both filenames are first passed to <code>normalize(String)</code>.
  The check is then performed in a case-sensitive manner.
 @param filename1 the first filename to query, may be null
 @param filename2 the second filename to query, may be null
 @return true if the filenames are equal, null equals null
 - seealso: IOCase#SENSITIVE
 */
+ (jboolean)equalsNormalizedWithNSString:(NSString *)filename1
                            withNSString:(NSString *)filename2;

/*!
 @brief Checks whether two filenames are equal after both have been normalized
  and using the case rules of the system.
 <p>
  Both filenames are first passed to <code>normalize(String)</code>.
  The check is then performed case-sensitive on Unix and
  case-insensitive on Windows.
 @param filename1 the first filename to query, may be null
 @param filename2 the second filename to query, may be null
 @return true if the filenames are equal, null equals null
 - seealso: IOCase#SYSTEM
 */
+ (jboolean)equalsNormalizedOnSystemWithNSString:(NSString *)filename1
                                    withNSString:(NSString *)filename2;

/*!
 @brief Checks whether two filenames are equal using the case rules of the system.
 <p>
  No processing is performed on the filenames other than comparison.
  The check is case-sensitive on Unix and case-insensitive on Windows.
 @param filename1 the first filename to query, may be null
 @param filename2 the second filename to query, may be null
 @return true if the filenames are equal, null equals null
 - seealso: IOCase#SYSTEM
 */
+ (jboolean)equalsOnSystemWithNSString:(NSString *)filename1
                          withNSString:(NSString *)filename2;

/*!
 @brief Gets the base name, minus the full path and extension, from a full filename.
 <p>
  This method will handle a file in either Unix or Windows format.
  The text after the last forward or backslash and before the last dot is returned. 
 @code

  a/b/c.txt --> c
  a.txt     --> a
  a/b/c     --> c
  a/b/c/    --> "" 
  
@endcode
  <p>
  The output will be the same irrespective of the machine that the code is running on.
 @param filename the filename to query, null returns null
 @return the name of the file without the path, or an empty string if none exists
 */
+ (NSString *)getBaseNameWithNSString:(NSString *)filename;

/*!
 @brief Gets the extension of a filename.
 <p>
  This method returns the textual part of the filename after the last dot.
  There must be no directory separator after the dot. 
 @code

  foo.txt      --> "txt"
  a/b/c.jpg    --> "jpg"
  a/b.txt/c    --> ""
  a/b/c        --> "" 
  
@endcode
  <p>
  The output will be the same irrespective of the machine that the code is running on.
 @param filename the filename to retrieve the extension of.
 @return the extension of the file or an empty string if none exists or <code>null</code>
  if the filename is <code>null</code>.
 */
+ (NSString *)getExtensionWithNSString:(NSString *)filename;

/*!
 @brief Gets the full path from a full filename, which is the prefix + path.
 <p>
  This method will handle a file in either Unix or Windows format.
  The method is entirely text based, and returns the text before and
  including the last forward or backslash. 
 @code

  C:\a\b\c.txt --> C:\a\b\
  ~/a/b/c.txt  --> ~/a/b/
  a.txt        --> ""
  a/b/c        --> a/b/
  a/b/c/       --> a/b/c/
  C:           --> C:
  C:\          --> C:\
  ~            --> ~/
  ~/           --> ~/
  ~user        --> ~user/
  ~user/       --> ~user/ 
  
@endcode
  <p>
  The output will be the same irrespective of the machine that the code is running on.
 @param filename the filename to query, null returns null
 @return the path of the file, an empty string if none exists, null if invalid
 */
+ (NSString *)getFullPathWithNSString:(NSString *)filename;

/*!
 @brief Gets the full path from a full filename, which is the prefix + path,
  and also excluding the final directory separator.
 <p>
  This method will handle a file in either Unix or Windows format.
  The method is entirely text based, and returns the text before the
  last forward or backslash. 
 @code

  C:\a\b\c.txt --> C:\a\b
  ~/a/b/c.txt  --> ~/a/b
  a.txt        --> ""
  a/b/c        --> a/b
  a/b/c/       --> a/b/c
  C:           --> C:
  C:\          --> C:\
  ~            --> ~
  ~/           --> ~
  ~user        --> ~user
  ~user/       --> ~user 
  
@endcode
  <p>
  The output will be the same irrespective of the machine that the code is running on.
 @param filename the filename to query, null returns null
 @return the path of the file, an empty string if none exists, null if invalid
 */
+ (NSString *)getFullPathNoEndSeparatorWithNSString:(NSString *)filename;

/*!
 @brief Gets the name minus the path from a full filename.
 <p>
  This method will handle a file in either Unix or Windows format.
  The text after the last forward or backslash is returned. 
 @code

  a/b/c.txt --> c.txt
  a.txt     --> a.txt
  a/b/c     --> c
  a/b/c/    --> "" 
  
@endcode
  <p>
  The output will be the same irrespective of the machine that the code is running on.
 @param filename the filename to query, null returns null
 @return the name of the file without the path, or an empty string if none exists
 */
+ (NSString *)getNameWithNSString:(NSString *)filename;

/*!
 @brief Gets the path from a full filename, which excludes the prefix.
 <p>
  This method will handle a file in either Unix or Windows format.
  The method is entirely text based, and returns the text before and
  including the last forward or backslash. 
 @code

  C:\a\b\c.txt --> a\b\
  ~/a/b/c.txt  --> a/b/
  a.txt        --> ""
  a/b/c        --> a/b/
  a/b/c/       --> a/b/c/ 
  
@endcode
  <p>
  The output will be the same irrespective of the machine that the code is running on. 
 <p>
  This method drops the prefix from the result.
  See <code>getFullPath(String)</code> for the method that retains the prefix.
 @param filename the filename to query, null returns null
 @return the path of the file, an empty string if none exists, null if invalid
 */
+ (NSString *)getPathWithNSString:(NSString *)filename;

/*!
 @brief Gets the path from a full filename, which excludes the prefix, and
  also excluding the final directory separator.
 <p>
  This method will handle a file in either Unix or Windows format.
  The method is entirely text based, and returns the text before the
  last forward or backslash. 
 @code

  C:\a\b\c.txt --> a\b
  ~/a/b/c.txt  --> a/b
  a.txt        --> ""
  a/b/c        --> a/b
  a/b/c/       --> a/b/c 
  
@endcode
  <p>
  The output will be the same irrespective of the machine that the code is running on. 
 <p>
  This method drops the prefix from the result.
  See <code>getFullPathNoEndSeparator(String)</code> for the method that retains the prefix.
 @param filename the filename to query, null returns null
 @return the path of the file, an empty string if none exists, null if invalid
 */
+ (NSString *)getPathNoEndSeparatorWithNSString:(NSString *)filename;

/*!
 @brief Gets the prefix from a full filename, such as <code>C:/</code>
  or <code>~/</code>.
 <p>
  This method will handle a file in either Unix or Windows format.
  The prefix includes the first slash in the full filename where applicable. 
 @code

  Windows:
  a\b\c.txt           --> ""          --> relative
  \a\b\c.txt          --> "\"         --> current drive absolute
  C:a\b\c.txt         --> "C:"        --> drive relative
  C:\a\b\c.txt        --> "C:\"       --> absolute
  \\server\a\b\c.txt  --> "\\server\" --> UNC
  Unix:
  a/b/c.txt           --> ""          --> relative
  /a/b/c.txt          --> "/"         --> absolute
  ~/a/b/c.txt         --> "~/"        --> current user
  ~                   --> "~/"        --> current user (slash added)
  ~user/a/b/c.txt     --> "~user/"    --> named user
  ~user               --> "~user/"    --> named user (slash added) 
  
@endcode
  <p>
  The output will be the same irrespective of the machine that the code is running on.
  ie. both Unix and Windows prefixes are matched regardless.
 @param filename the filename to query, null returns null
 @return the prefix of the file, null if invalid
 */
+ (NSString *)getPrefixWithNSString:(NSString *)filename;

/*!
 @brief Returns the length of the filename prefix, such as <code>C:/</code> or <code>~/</code>.
 <p>
  This method will handle a file in either Unix or Windows format. 
 <p>
  The prefix length includes the first slash in the full filename
  if applicable. Thus, it is possible that the length returned is greater
  than the length of the input string. 
 @code

  Windows:
  a\b\c.txt           --> ""          --> relative
  \a\b\c.txt          --> "\"         --> current drive absolute
  C:a\b\c.txt         --> "C:"        --> drive relative
  C:\a\b\c.txt        --> "C:\"       --> absolute
  \\server\a\b\c.txt  --> "\\server\" --> UNC
  Unix:
  a/b/c.txt           --> ""          --> relative
  /a/b/c.txt          --> "/"         --> absolute
  ~/a/b/c.txt         --> "~/"        --> current user
  ~                   --> "~/"        --> current user (slash added)
  ~user/a/b/c.txt     --> "~user/"    --> named user
  ~user               --> "~user/"    --> named user (slash added) 
  
@endcode
  <p>
  The output will be the same irrespective of the machine that the code is running on.
  ie. both Unix and Windows prefixes are matched regardless.
 @param filename the filename to find the prefix in, null returns -1
 @return the length of the prefix, -1 if invalid or null
 */
+ (jint)getPrefixLengthWithNSString:(NSString *)filename;

/*!
 @brief Returns the index of the last extension separator character, which is a dot.
 <p>
  This method also checks that there is no directory separator after the last dot.
  To do this it uses <code>indexOfLastSeparator(String)</code> which will
  handle a file in either Unix or Windows format. 
 <p>
  The output will be the same irrespective of the machine that the code is running on.
 @param filename the filename to find the last path separator in, null returns -1
 @return the index of the last separator character, or -1 if there
  is no such character
 */
+ (jint)indexOfExtensionWithNSString:(NSString *)filename;

/*!
 @brief Returns the index of the last directory separator character.
 <p>
  This method will handle a file in either Unix or Windows format.
  The position of the last forward or backslash is returned. 
 <p>
  The output will be the same irrespective of the machine that the code is running on.
 @param filename the filename to find the last path separator in, null returns -1
 @return the index of the last separator character, or -1 if there
  is no such character
 */
+ (jint)indexOfLastSeparatorWithNSString:(NSString *)filename;

/*!
 @brief Checks whether the extension of the filename is one of those specified.
 <p>
  This method obtains the extension as the textual part of the filename
  after the last dot. There must be no directory separator after the dot.
  The extension check is case-sensitive on all platforms.
 @param filename the filename to query, null returns false
 @param extensions the extensions to check for, null checks for no extension
 @return true if the filename is one of the extensions
 */
+ (jboolean)isExtensionWithNSString:(NSString *)filename
             withJavaUtilCollection:(id<JavaUtilCollection>)extensions;

/*!
 @brief Checks whether the extension of the filename is that specified.
 <p>
  This method obtains the extension as the textual part of the filename
  after the last dot. There must be no directory separator after the dot.
  The extension check is case-sensitive on all platforms.
 @param filename the filename to query, null returns false
 @param extension the extension to check for, null or empty checks for no extension
 @return true if the filename has the specified extension
 */
+ (jboolean)isExtensionWithNSString:(NSString *)filename
                       withNSString:(NSString *)extension;

/*!
 @brief Checks whether the extension of the filename is one of those specified.
 <p>
  This method obtains the extension as the textual part of the filename
  after the last dot. There must be no directory separator after the dot.
  The extension check is case-sensitive on all platforms.
 @param filename the filename to query, null returns false
 @param extensions the extensions to check for, null checks for no extension
 @return true if the filename is one of the extensions
 */
+ (jboolean)isExtensionWithNSString:(NSString *)filename
                  withNSStringArray:(IOSObjectArray *)extensions;

/*!
 @brief Normalizes a path, removing double and single dot path steps.
 <p>
  This method normalizes a path to a standard format.
  The input may contain separators in either Unix or Windows format.
  The output will contain separators in the format of the system. 
 <p>
  A trailing slash will be retained.
  A double slash will be merged to a single slash (but UNC names are handled).
  A single dot path segment will be removed.
  A double dot will cause that path segment and the one before to be removed.
  If the double dot has no parent path segment to work with, <code>null</code>
  is returned. 
 <p>
  The output will be the same on both Unix and Windows except
  for the separator character. 
 @code

  /foo//               -->   /foo/
  /foo/./              -->   /foo/
  /foo/../bar          -->   /bar
  /foo/../bar/         -->   /bar/
  /foo/../bar/../baz   -->   /baz
  //foo//./bar         -->   /foo/bar
  /../                 -->   null
  ../foo               -->   null
  foo/bar/..           -->   foo/
  foo/../../bar        -->   null
  foo/../bar           -->   bar
  //server/foo/../bar  -->   //server/bar
  //server/../bar      -->   null
  C:\foo\..\bar        -->   C:\bar
  C:\..\bar            -->   null
  ~/foo/../bar/        -->   ~/bar/
  ~/../bar             -->   null 
  
@endcode
  (Note the file separator returned will be correct for Windows/Unix)
 @param filename the filename to normalize, null returns null
 @return the normalized filename, or null if invalid
 */
+ (NSString *)normalizeWithNSString:(NSString *)filename;

/*!
 @brief Normalizes a path, removing double and single dot path steps.
 <p>
  This method normalizes a path to a standard format.
  The input may contain separators in either Unix or Windows format.
  The output will contain separators in the format specified. 
 <p>
  A trailing slash will be retained.
  A double slash will be merged to a single slash (but UNC names are handled).
  A single dot path segment will be removed.
  A double dot will cause that path segment and the one before to be removed.
  If the double dot has no parent path segment to work with, <code>null</code>
  is returned. 
 <p>
  The output will be the same on both Unix and Windows except
  for the separator character. 
 @code

  /foo//               -->   /foo/
  /foo/./              -->   /foo/
  /foo/../bar          -->   /bar
  /foo/../bar/         -->   /bar/
  /foo/../bar/../baz   -->   /baz
  //foo//./bar         -->   /foo/bar
  /../                 -->   null
  ../foo               -->   null
  foo/bar/..           -->   foo/
  foo/../../bar        -->   null
  foo/../bar           -->   bar
  //server/foo/../bar  -->   //server/bar
  //server/../bar      -->   null
  C:\foo\..\bar        -->   C:\bar
  C:\..\bar            -->   null
  ~/foo/../bar/        -->   ~/bar/
  ~/../bar             -->   null 
  
@endcode
  The output will be the same on both Unix and Windows including
  the separator character.
 @param filename the filename to normalize, null returns null
 @param unixSeparator<code>true</code>  if a unix separator should  be used or 
 <code>false</code>  if a windows separator should be used.
 @return the normalized filename, or null if invalid
 @since 2.0
 */
+ (NSString *)normalizeWithNSString:(NSString *)filename
                        withBoolean:(jboolean)unixSeparator;

/*!
 @brief Normalizes a path, removing double and single dot path steps,
  and removing any final directory separator.
 <p>
  This method normalizes a path to a standard format.
  The input may contain separators in either Unix or Windows format.
  The output will contain separators in the format of the system. 
 <p>
  A trailing slash will be removed.
  A double slash will be merged to a single slash (but UNC names are handled).
  A single dot path segment will be removed.
  A double dot will cause that path segment and the one before to be removed.
  If the double dot has no parent path segment to work with, <code>null</code>
  is returned. 
 <p>
  The output will be the same on both Unix and Windows except
  for the separator character. 
 @code

  /foo//               -->   /foo
  /foo/./              -->   /foo
  /foo/../bar          -->   /bar
  /foo/../bar/         -->   /bar
  /foo/../bar/../baz   -->   /baz
  //foo//./bar         -->   /foo/bar
  /../                 -->   null
  ../foo               -->   null
  foo/bar/..           -->   foo
  foo/../../bar        -->   null
  foo/../bar           -->   bar
  //server/foo/../bar  -->   //server/bar
  //server/../bar      -->   null
  C:\foo\..\bar        -->   C:\bar
  C:\..\bar            -->   null
  ~/foo/../bar/        -->   ~/bar
  ~/../bar             -->   null 
  
@endcode
  (Note the file separator returned will be correct for Windows/Unix)
 @param filename the filename to normalize, null returns null
 @return the normalized filename, or null if invalid
 */
+ (NSString *)normalizeNoEndSeparatorWithNSString:(NSString *)filename;

/*!
 @brief Normalizes a path, removing double and single dot path steps,
  and removing any final directory separator.
 <p>
  This method normalizes a path to a standard format.
  The input may contain separators in either Unix or Windows format.
  The output will contain separators in the format specified. 
 <p>
  A trailing slash will be removed.
  A double slash will be merged to a single slash (but UNC names are handled).
  A single dot path segment will be removed.
  A double dot will cause that path segment and the one before to be removed.
  If the double dot has no parent path segment to work with, <code>null</code>
  is returned. 
 <p>
  The output will be the same on both Unix and Windows including
  the separator character. 
 @code

  /foo//               -->   /foo
  /foo/./              -->   /foo
  /foo/../bar          -->   /bar
  /foo/../bar/         -->   /bar
  /foo/../bar/../baz   -->   /baz
  //foo//./bar         -->   /foo/bar
  /../                 -->   null
  ../foo               -->   null
  foo/bar/..           -->   foo
  foo/../../bar        -->   null
  foo/../bar           -->   bar
  //server/foo/../bar  -->   //server/bar
  //server/../bar      -->   null
  C:\foo\..\bar        -->   C:\bar
  C:\..\bar            -->   null
  ~/foo/../bar/        -->   ~/bar
  ~/../bar             -->   null 
  
@endcode
 @param filename the filename to normalize, null returns null
 @param unixSeparator<code>true</code>  if a unix separator should  be used or 
 <code>false</code>  if a windows separtor should be used.
 @return the normalized filename, or null if invalid
 @since 2.0
 */
+ (NSString *)normalizeNoEndSeparatorWithNSString:(NSString *)filename
                                      withBoolean:(jboolean)unixSeparator;

/*!
 @brief Removes the extension from a filename.
 <p>
  This method returns the textual part of the filename before the last dot.
  There must be no directory separator after the dot. 
 @code

  foo.txt    --> foo
  a\b\c.jpg  --> a\b\c
  a\b\c      --> a\b\c
  a.b\c      --> a.b\c 
  
@endcode
  <p>
  The output will be the same irrespective of the machine that the code is running on.
 @param filename the filename to query, null returns null
 @return the filename minus the extension
 */
+ (NSString *)removeExtensionWithNSString:(NSString *)filename;

/*!
 @brief Converts all separators to the system separator.
 @param path the path to be changed, null ignored
 @return the updated path
 */
+ (NSString *)separatorsToSystemWithNSString:(NSString *)path;

/*!
 @brief Converts all separators to the Unix separator of forward slash.
 @param path the path to be changed, null ignored
 @return the updated path
 */
+ (NSString *)separatorsToUnixWithNSString:(NSString *)path;

/*!
 @brief Converts all separators to the Windows separator of backslash.
 @param path the path to be changed, null ignored
 @return the updated path
 */
+ (NSString *)separatorsToWindowsWithNSString:(NSString *)path;

/*!
 @brief Checks a filename to see if it matches the specified wildcard matcher,
  always testing case-sensitive.
 <p>
  The wildcard matcher uses the characters '?' and '*' to represent a
  single or multiple (zero or more) wildcard characters.
  This is the same as often found on Dos/Unix command lines.
  The check is case-sensitive always. 
 @code

  wildcardMatch("c.txt", "*.txt")      --> true
  wildcardMatch("c.txt", "*.jpg")      --> false
  wildcardMatch("a/b/c.txt", "a/b/\*")  --> true
  wildcardMatch("c.txt", "*.???")      --> true
  wildcardMatch("c.txt", "*.????")     --> false 
  
@endcode
  N.B. the sequence "*?" does not work properly at present in match strings.
 @param filename the filename to match on
 @param wildcardMatcher the wildcard string to match against
 @return true if the filename matches the wilcard string
 - seealso: IOCase#SENSITIVE
 */
+ (jboolean)wildcardMatchWithNSString:(NSString *)filename
                         withNSString:(NSString *)wildcardMatcher;

/*!
 @brief Checks a filename to see if it matches the specified wildcard matcher
  allowing control over case-sensitivity.
 <p>
  The wildcard matcher uses the characters '?' and '*' to represent a
  single or multiple (zero or more) wildcard characters.
  N.B. the sequence "*?" does not work properly at present in match strings.
 @param filename the filename to match on
 @param wildcardMatcher the wildcard string to match against
 @param caseSensitivity what case sensitivity rule to use, null means case-sensitive
 @return true if the filename matches the wilcard string
 @since 1.3
 */
+ (jboolean)wildcardMatchWithNSString:(NSString *)filename
                         withNSString:(NSString *)wildcardMatcher
         withOrgApacheCommonsIoIOCase:(OrgApacheCommonsIoIOCase *)caseSensitivity;

/*!
 @brief Checks a filename to see if it matches the specified wildcard matcher
  using the case rules of the system.
 <p>
  The wildcard matcher uses the characters '?' and '*' to represent a
  single or multiple (zero or more) wildcard characters.
  This is the same as often found on Dos/Unix command lines.
  The check is case-sensitive on Unix and case-insensitive on Windows. 
 @code

  wildcardMatch("c.txt", "*.txt")      --> true
  wildcardMatch("c.txt", "*.jpg")      --> false
  wildcardMatch("a/b/c.txt", "a/b/\*")  --> true
  wildcardMatch("c.txt", "*.???")      --> true
  wildcardMatch("c.txt", "*.????")     --> false 
  
@endcode
  N.B. the sequence "*?" does not work properly at present in match strings.
 @param filename the filename to match on
 @param wildcardMatcher the wildcard string to match against
 @return true if the filename matches the wilcard string
 - seealso: IOCase#SYSTEM
 */
+ (jboolean)wildcardMatchOnSystemWithNSString:(NSString *)filename
                                 withNSString:(NSString *)wildcardMatcher;

#pragma mark Package-Private

/*!
 @brief Determines if Windows file system is in use.
 @return true if the system is Windows
 */
+ (jboolean)isSystemWindows;

/*!
 @brief Splits a string into a number of tokens.
 The text is split by '?' and '*'.
  Where multiple '*' occur consecutively they are collapsed into a single '*'.
 @param text the text to split
 @return the array of tokens, never null
 */
+ (IOSObjectArray *)splitOnTokensWithNSString:(NSString *)text;

@end

J2OBJC_STATIC_INIT(OrgApacheCommonsIoFilenameUtils)

/*!
 @brief The extension separator character.
 @since 1.4
 */
inline jchar OrgApacheCommonsIoFilenameUtils_get_EXTENSION_SEPARATOR(void);
#define OrgApacheCommonsIoFilenameUtils_EXTENSION_SEPARATOR '.'
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheCommonsIoFilenameUtils, EXTENSION_SEPARATOR, jchar)

/*!
 @brief The extension separator String.
 @since 1.4
 */
inline NSString *OrgApacheCommonsIoFilenameUtils_get_EXTENSION_SEPARATOR_STR(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT NSString *OrgApacheCommonsIoFilenameUtils_EXTENSION_SEPARATOR_STR;
J2OBJC_STATIC_FIELD_OBJ_FINAL(OrgApacheCommonsIoFilenameUtils, EXTENSION_SEPARATOR_STR, NSString *)

FOUNDATION_EXPORT void OrgApacheCommonsIoFilenameUtils_init(OrgApacheCommonsIoFilenameUtils *self);

FOUNDATION_EXPORT OrgApacheCommonsIoFilenameUtils *new_OrgApacheCommonsIoFilenameUtils_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgApacheCommonsIoFilenameUtils *create_OrgApacheCommonsIoFilenameUtils_init(void);

FOUNDATION_EXPORT jboolean OrgApacheCommonsIoFilenameUtils_isSystemWindows(void);

FOUNDATION_EXPORT NSString *OrgApacheCommonsIoFilenameUtils_normalizeWithNSString_(NSString *filename);

FOUNDATION_EXPORT NSString *OrgApacheCommonsIoFilenameUtils_normalizeWithNSString_withBoolean_(NSString *filename, jboolean unixSeparator);

FOUNDATION_EXPORT NSString *OrgApacheCommonsIoFilenameUtils_normalizeNoEndSeparatorWithNSString_(NSString *filename);

FOUNDATION_EXPORT NSString *OrgApacheCommonsIoFilenameUtils_normalizeNoEndSeparatorWithNSString_withBoolean_(NSString *filename, jboolean unixSeparator);

FOUNDATION_EXPORT NSString *OrgApacheCommonsIoFilenameUtils_concatWithNSString_withNSString_(NSString *basePath, NSString *fullFilenameToAdd);

FOUNDATION_EXPORT jboolean OrgApacheCommonsIoFilenameUtils_directoryContainsWithNSString_withNSString_(NSString *canonicalParent, NSString *canonicalChild);

FOUNDATION_EXPORT NSString *OrgApacheCommonsIoFilenameUtils_separatorsToUnixWithNSString_(NSString *path);

FOUNDATION_EXPORT NSString *OrgApacheCommonsIoFilenameUtils_separatorsToWindowsWithNSString_(NSString *path);

FOUNDATION_EXPORT NSString *OrgApacheCommonsIoFilenameUtils_separatorsToSystemWithNSString_(NSString *path);

FOUNDATION_EXPORT jint OrgApacheCommonsIoFilenameUtils_getPrefixLengthWithNSString_(NSString *filename);

FOUNDATION_EXPORT jint OrgApacheCommonsIoFilenameUtils_indexOfLastSeparatorWithNSString_(NSString *filename);

FOUNDATION_EXPORT jint OrgApacheCommonsIoFilenameUtils_indexOfExtensionWithNSString_(NSString *filename);

FOUNDATION_EXPORT NSString *OrgApacheCommonsIoFilenameUtils_getPrefixWithNSString_(NSString *filename);

FOUNDATION_EXPORT NSString *OrgApacheCommonsIoFilenameUtils_getPathWithNSString_(NSString *filename);

FOUNDATION_EXPORT NSString *OrgApacheCommonsIoFilenameUtils_getPathNoEndSeparatorWithNSString_(NSString *filename);

FOUNDATION_EXPORT NSString *OrgApacheCommonsIoFilenameUtils_getFullPathWithNSString_(NSString *filename);

FOUNDATION_EXPORT NSString *OrgApacheCommonsIoFilenameUtils_getFullPathNoEndSeparatorWithNSString_(NSString *filename);

FOUNDATION_EXPORT NSString *OrgApacheCommonsIoFilenameUtils_getNameWithNSString_(NSString *filename);

FOUNDATION_EXPORT NSString *OrgApacheCommonsIoFilenameUtils_getBaseNameWithNSString_(NSString *filename);

FOUNDATION_EXPORT NSString *OrgApacheCommonsIoFilenameUtils_getExtensionWithNSString_(NSString *filename);

FOUNDATION_EXPORT NSString *OrgApacheCommonsIoFilenameUtils_removeExtensionWithNSString_(NSString *filename);

FOUNDATION_EXPORT jboolean OrgApacheCommonsIoFilenameUtils_equalsWithNSString_withNSString_(NSString *filename1, NSString *filename2);

FOUNDATION_EXPORT jboolean OrgApacheCommonsIoFilenameUtils_equalsOnSystemWithNSString_withNSString_(NSString *filename1, NSString *filename2);

FOUNDATION_EXPORT jboolean OrgApacheCommonsIoFilenameUtils_equalsNormalizedWithNSString_withNSString_(NSString *filename1, NSString *filename2);

FOUNDATION_EXPORT jboolean OrgApacheCommonsIoFilenameUtils_equalsNormalizedOnSystemWithNSString_withNSString_(NSString *filename1, NSString *filename2);

FOUNDATION_EXPORT jboolean OrgApacheCommonsIoFilenameUtils_equalsWithNSString_withNSString_withBoolean_withOrgApacheCommonsIoIOCase_(NSString *filename1, NSString *filename2, jboolean normalized, OrgApacheCommonsIoIOCase *caseSensitivity);

FOUNDATION_EXPORT jboolean OrgApacheCommonsIoFilenameUtils_isExtensionWithNSString_withNSString_(NSString *filename, NSString *extension);

FOUNDATION_EXPORT jboolean OrgApacheCommonsIoFilenameUtils_isExtensionWithNSString_withNSStringArray_(NSString *filename, IOSObjectArray *extensions);

FOUNDATION_EXPORT jboolean OrgApacheCommonsIoFilenameUtils_isExtensionWithNSString_withJavaUtilCollection_(NSString *filename, id<JavaUtilCollection> extensions);

FOUNDATION_EXPORT jboolean OrgApacheCommonsIoFilenameUtils_wildcardMatchWithNSString_withNSString_(NSString *filename, NSString *wildcardMatcher);

FOUNDATION_EXPORT jboolean OrgApacheCommonsIoFilenameUtils_wildcardMatchOnSystemWithNSString_withNSString_(NSString *filename, NSString *wildcardMatcher);

FOUNDATION_EXPORT jboolean OrgApacheCommonsIoFilenameUtils_wildcardMatchWithNSString_withNSString_withOrgApacheCommonsIoIOCase_(NSString *filename, NSString *wildcardMatcher, OrgApacheCommonsIoIOCase *caseSensitivity);

FOUNDATION_EXPORT IOSObjectArray *OrgApacheCommonsIoFilenameUtils_splitOnTokensWithNSString_(NSString *text);

J2OBJC_TYPE_LITERAL_HEADER(OrgApacheCommonsIoFilenameUtils)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif
#pragma pop_macro("INCLUDE_ALL_OrgApacheCommonsIoFilenameUtils")
