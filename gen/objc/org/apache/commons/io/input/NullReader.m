//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/marcussmith/temp/commons-io/src/main/java/org/apache/commons/io/input/NullReader.java
//

#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/io/EOFException.h"
#include "java/io/IOException.h"
#include "java/io/Reader.h"
#include "java/lang/UnsupportedOperationException.h"
#include "org/apache/commons/io/input/NullReader.h"

@interface OrgApacheCommonsIoInputNullReader () {
 @public
  jlong size_;
  jlong position_;
  jlong mark_;
  jlong readlimit_;
  jboolean eof_;
  jboolean throwEofException_;
  jboolean markSupported_;
}

@end

__attribute__((unused)) static jint OrgApacheCommonsIoInputNullReader_doEndOfFile(OrgApacheCommonsIoInputNullReader *self);

@implementation OrgApacheCommonsIoInputNullReader

- (instancetype __nonnull)initWithLong:(jlong)size {
  OrgApacheCommonsIoInputNullReader_initWithLong_(self, size);
  return self;
}

- (instancetype __nonnull)initWithLong:(jlong)size
                           withBoolean:(jboolean)markSupported
                           withBoolean:(jboolean)throwEofException {
  OrgApacheCommonsIoInputNullReader_initWithLong_withBoolean_withBoolean_(self, size, markSupported, throwEofException);
  return self;
}

- (jlong)getPosition {
  return position_;
}

- (jlong)getSize {
  return size_;
}

- (void)close {
  eof_ = false;
  position_ = 0;
  mark_ = -1;
}

- (void)markWithInt:(jint)readlimit {
  @synchronized(self) {
    if (!markSupported_) {
      @throw create_JavaLangUnsupportedOperationException_initWithNSString_(@"Mark not supported");
    }
    mark_ = position_;
    self->readlimit_ = readlimit;
  }
}

- (jboolean)markSupported {
  return markSupported_;
}

- (jint)read {
  if (eof_) {
    @throw create_JavaIoIOException_initWithNSString_(@"Read after end of file");
  }
  if (position_ == size_) {
    return OrgApacheCommonsIoInputNullReader_doEndOfFile(self);
  }
  position_++;
  return [self processChar];
}

- (jint)readWithCharArray:(IOSCharArray *)chars {
  return [self readWithCharArray:chars withInt:0 withInt:((IOSCharArray *) nil_chk(chars))->size_];
}

- (jint)readWithCharArray:(IOSCharArray *)chars
                  withInt:(jint)offset
                  withInt:(jint)length {
  if (eof_) {
    @throw create_JavaIoIOException_initWithNSString_(@"Read after end of file");
  }
  if (position_ == size_) {
    return OrgApacheCommonsIoInputNullReader_doEndOfFile(self);
  }
  position_ += length;
  jint returnLength = length;
  if (position_ > size_) {
    returnLength = length - (jint) (position_ - size_);
    position_ = size_;
  }
  [self processCharsWithCharArray:chars withInt:offset withInt:returnLength];
  return returnLength;
}

- (void)reset {
  @synchronized(self) {
    if (!markSupported_) {
      @throw create_JavaLangUnsupportedOperationException_initWithNSString_(@"Mark not supported");
    }
    if (mark_ < 0) {
      @throw create_JavaIoIOException_initWithNSString_(@"No position has been marked");
    }
    if (position_ > mark_ + readlimit_) {
      @throw create_JavaIoIOException_initWithNSString_(JreStrcat("$J$JC", @"Marked position [", mark_, @"] is no longer valid - passed the read limit [", readlimit_, ']'));
    }
    position_ = mark_;
    eof_ = false;
  }
}

- (jlong)skipWithLong:(jlong)numberOfChars {
  if (eof_) {
    @throw create_JavaIoIOException_initWithNSString_(@"Skip after end of file");
  }
  if (position_ == size_) {
    return OrgApacheCommonsIoInputNullReader_doEndOfFile(self);
  }
  position_ += numberOfChars;
  jlong returnLength = numberOfChars;
  if (position_ > size_) {
    returnLength = numberOfChars - (position_ - size_);
    position_ = size_;
  }
  return returnLength;
}

- (jint)processChar {
  return 0;
}

- (void)processCharsWithCharArray:(IOSCharArray *)chars
                          withInt:(jint)offset
                          withInt:(jint)length {
}

@end

void OrgApacheCommonsIoInputNullReader_initWithLong_(OrgApacheCommonsIoInputNullReader *self, jlong size) {
  OrgApacheCommonsIoInputNullReader_initWithLong_withBoolean_withBoolean_(self, size, true, false);
}

OrgApacheCommonsIoInputNullReader *new_OrgApacheCommonsIoInputNullReader_initWithLong_(jlong size) {
  J2OBJC_NEW_IMPL(OrgApacheCommonsIoInputNullReader, initWithLong_, size)
}

OrgApacheCommonsIoInputNullReader *create_OrgApacheCommonsIoInputNullReader_initWithLong_(jlong size) {
  J2OBJC_CREATE_IMPL(OrgApacheCommonsIoInputNullReader, initWithLong_, size)
}

void OrgApacheCommonsIoInputNullReader_initWithLong_withBoolean_withBoolean_(OrgApacheCommonsIoInputNullReader *self, jlong size, jboolean markSupported, jboolean throwEofException) {
  JavaIoReader_init(self);
  self->mark_ = -1;
  self->size_ = size;
  self->markSupported_ = markSupported;
  self->throwEofException_ = throwEofException;
}

OrgApacheCommonsIoInputNullReader *new_OrgApacheCommonsIoInputNullReader_initWithLong_withBoolean_withBoolean_(jlong size, jboolean markSupported, jboolean throwEofException) {
  J2OBJC_NEW_IMPL(OrgApacheCommonsIoInputNullReader, initWithLong_withBoolean_withBoolean_, size, markSupported, throwEofException)
}

OrgApacheCommonsIoInputNullReader *create_OrgApacheCommonsIoInputNullReader_initWithLong_withBoolean_withBoolean_(jlong size, jboolean markSupported, jboolean throwEofException) {
  J2OBJC_CREATE_IMPL(OrgApacheCommonsIoInputNullReader, initWithLong_withBoolean_withBoolean_, size, markSupported, throwEofException)
}

jint OrgApacheCommonsIoInputNullReader_doEndOfFile(OrgApacheCommonsIoInputNullReader *self) {
  self->eof_ = true;
  if (self->throwEofException_) {
    @throw create_JavaIoEOFException_init();
  }
  return -1;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OrgApacheCommonsIoInputNullReader)
